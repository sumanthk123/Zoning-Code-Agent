# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.supported_ll_ms import SupportedLlMs
from ..types.task_created_response import TaskCreatedResponse
from ..types.task_list_response import TaskListResponse
from ..types.task_log_file_response import TaskLogFileResponse
from ..types.task_status import TaskStatus
from ..types.task_update_action import TaskUpdateAction
from ..types.task_view import TaskView
from ..types.too_many_concurrent_active_sessions_error import TooManyConcurrentActiveSessionsError
from .types.create_task_request_vision import CreateTaskRequestVision

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTasksClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_tasks(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        session_id: typing.Optional[str] = None,
        filter_by: typing.Optional[TaskStatus] = None,
        after: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TaskListResponse]:
        """
        Get paginated list of AI agent tasks with optional filtering by session and status.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        session_id : typing.Optional[str]

        filter_by : typing.Optional[TaskStatus]

        after : typing.Optional[dt.datetime]

        before : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TaskListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "sessionId": session_id,
                "filterBy": filter_by,
                "after": serialize_datetime(after) if after is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskListResponse,
                    construct_type(
                        type_=TaskListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_task(
        self,
        *,
        task: str,
        llm: typing.Optional[SupportedLlMs] = OMIT,
        start_url: typing.Optional[str] = OMIT,
        max_steps: typing.Optional[int] = OMIT,
        structured_output: typing.Optional[str] = OMIT,
        session_id: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        secrets: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        allowed_domains: typing.Optional[typing.Sequence[str]] = OMIT,
        op_vault_id: typing.Optional[str] = OMIT,
        highlight_elements: typing.Optional[bool] = OMIT,
        flash_mode: typing.Optional[bool] = OMIT,
        thinking: typing.Optional[bool] = OMIT,
        vision: typing.Optional[CreateTaskRequestVision] = OMIT,
        system_prompt_extension: typing.Optional[str] = OMIT,
        judge: typing.Optional[bool] = OMIT,
        judge_ground_truth: typing.Optional[str] = OMIT,
        judge_llm: typing.Optional[SupportedLlMs] = OMIT,
        skill_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TaskCreatedResponse]:
        """
        Create and start a new task.

        You can either:
        1. Start a new task without a sessionId (auto-creates a session with US proxy by default)
        2. Start a new task in an existing session (reuse for follow-up tasks or custom configuration)

        Important: Proxy configuration (proxyCountryCode) is a session-level setting, not a task-level setting.
        To use a custom proxy location, create a session first via POST /sessions with your desired proxyCountryCode,
        then pass that sessionId when creating tasks.

        Parameters
        ----------
        task : str
            The task prompt/instruction for the agent.

        llm : typing.Optional[SupportedLlMs]
            The LLM model to use for the agent.

        start_url : typing.Optional[str]
            The URL to start the task from.

        max_steps : typing.Optional[int]
            Maximum number of steps the agent can take before stopping.

        structured_output : typing.Optional[str]
            The stringified JSON schema for the structured output.

        session_id : typing.Optional[str]
            The ID of the session where the task will run.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            The metadata for the task. Up to 10 key-value pairs.

        secrets : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            The secrets for the task. Allowed domains are not required for secrets to be injected, but are recommended.

        allowed_domains : typing.Optional[typing.Sequence[str]]
            The allowed domains for the task.

        op_vault_id : typing.Optional[str]
            The ID of the 1Password vault to use for the task. This is used to inject secrets into the task.

        highlight_elements : typing.Optional[bool]
            Tells the agent to highlight interactive elements on the page.

        flash_mode : typing.Optional[bool]
            Whether agent flash mode is enabled.

        thinking : typing.Optional[bool]
            Whether agent thinking mode is enabled.

        vision : typing.Optional[CreateTaskRequestVision]
            Whether agent vision capabilities are enabled. Set to 'auto' to let the agent decide based on the model capabilities.

        system_prompt_extension : typing.Optional[str]
            Optional extension to the agent system prompt.

        judge : typing.Optional[bool]
            Enable judge mode to evaluate task completion against ground truth.

        judge_ground_truth : typing.Optional[str]
            Expected answer for judge evaluation.

        judge_llm : typing.Optional[SupportedLlMs]
            The LLM model to use for judging. If not provided, uses the default judge LLM.

        skill_ids : typing.Optional[typing.Sequence[str]]
            List of skill IDs to enable for this task. Use ['*'] to enable all available skills for the project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TaskCreatedResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tasks",
            method="POST",
            json={
                "task": task,
                "llm": llm,
                "startUrl": start_url,
                "maxSteps": max_steps,
                "structuredOutput": structured_output,
                "sessionId": session_id,
                "metadata": metadata,
                "secrets": secrets,
                "allowedDomains": allowed_domains,
                "opVaultId": op_vault_id,
                "highlightElements": highlight_elements,
                "flashMode": flash_mode,
                "thinking": thinking,
                "vision": convert_and_respect_annotation_metadata(
                    object_=vision, annotation=CreateTaskRequestVision, direction="write"
                ),
                "systemPromptExtension": system_prompt_extension,
                "judge": judge,
                "judgeGroundTruth": judge_ground_truth,
                "judgeLlm": judge_llm,
                "skillIds": skill_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskCreatedResponse,
                    construct_type(
                        type_=TaskCreatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyConcurrentActiveSessionsError,
                        construct_type(
                            type_=TooManyConcurrentActiveSessionsError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_task(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[TaskView]:
        """
        Get detailed task information including status, progress, steps, and file outputs.

        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TaskView]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskView,
                    construct_type(
                        type_=TaskView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_task(
        self, task_id: str, *, action: TaskUpdateAction, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[TaskView]:
        """
        Control task execution with stop, pause, resume, or stop task and session actions.

        Parameters
        ----------
        task_id : str

        action : TaskUpdateAction
            The action to perform on the task

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TaskView]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="PATCH",
            json={
                "action": action,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskView,
                    construct_type(
                        type_=TaskView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_task_logs(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[TaskLogFileResponse]:
        """
        Get secure download URL for task execution logs with step-by-step details.

        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TaskLogFileResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}/logs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskLogFileResponse,
                    construct_type(
                        type_=TaskLogFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawTasksClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_tasks(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        session_id: typing.Optional[str] = None,
        filter_by: typing.Optional[TaskStatus] = None,
        after: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TaskListResponse]:
        """
        Get paginated list of AI agent tasks with optional filtering by session and status.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        session_id : typing.Optional[str]

        filter_by : typing.Optional[TaskStatus]

        after : typing.Optional[dt.datetime]

        before : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TaskListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "sessionId": session_id,
                "filterBy": filter_by,
                "after": serialize_datetime(after) if after is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskListResponse,
                    construct_type(
                        type_=TaskListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_task(
        self,
        *,
        task: str,
        llm: typing.Optional[SupportedLlMs] = OMIT,
        start_url: typing.Optional[str] = OMIT,
        max_steps: typing.Optional[int] = OMIT,
        structured_output: typing.Optional[str] = OMIT,
        session_id: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        secrets: typing.Optional[typing.Dict[str, typing.Optional[str]]] = OMIT,
        allowed_domains: typing.Optional[typing.Sequence[str]] = OMIT,
        op_vault_id: typing.Optional[str] = OMIT,
        highlight_elements: typing.Optional[bool] = OMIT,
        flash_mode: typing.Optional[bool] = OMIT,
        thinking: typing.Optional[bool] = OMIT,
        vision: typing.Optional[CreateTaskRequestVision] = OMIT,
        system_prompt_extension: typing.Optional[str] = OMIT,
        judge: typing.Optional[bool] = OMIT,
        judge_ground_truth: typing.Optional[str] = OMIT,
        judge_llm: typing.Optional[SupportedLlMs] = OMIT,
        skill_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TaskCreatedResponse]:
        """
        Create and start a new task.

        You can either:
        1. Start a new task without a sessionId (auto-creates a session with US proxy by default)
        2. Start a new task in an existing session (reuse for follow-up tasks or custom configuration)

        Important: Proxy configuration (proxyCountryCode) is a session-level setting, not a task-level setting.
        To use a custom proxy location, create a session first via POST /sessions with your desired proxyCountryCode,
        then pass that sessionId when creating tasks.

        Parameters
        ----------
        task : str
            The task prompt/instruction for the agent.

        llm : typing.Optional[SupportedLlMs]
            The LLM model to use for the agent.

        start_url : typing.Optional[str]
            The URL to start the task from.

        max_steps : typing.Optional[int]
            Maximum number of steps the agent can take before stopping.

        structured_output : typing.Optional[str]
            The stringified JSON schema for the structured output.

        session_id : typing.Optional[str]
            The ID of the session where the task will run.

        metadata : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            The metadata for the task. Up to 10 key-value pairs.

        secrets : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            The secrets for the task. Allowed domains are not required for secrets to be injected, but are recommended.

        allowed_domains : typing.Optional[typing.Sequence[str]]
            The allowed domains for the task.

        op_vault_id : typing.Optional[str]
            The ID of the 1Password vault to use for the task. This is used to inject secrets into the task.

        highlight_elements : typing.Optional[bool]
            Tells the agent to highlight interactive elements on the page.

        flash_mode : typing.Optional[bool]
            Whether agent flash mode is enabled.

        thinking : typing.Optional[bool]
            Whether agent thinking mode is enabled.

        vision : typing.Optional[CreateTaskRequestVision]
            Whether agent vision capabilities are enabled. Set to 'auto' to let the agent decide based on the model capabilities.

        system_prompt_extension : typing.Optional[str]
            Optional extension to the agent system prompt.

        judge : typing.Optional[bool]
            Enable judge mode to evaluate task completion against ground truth.

        judge_ground_truth : typing.Optional[str]
            Expected answer for judge evaluation.

        judge_llm : typing.Optional[SupportedLlMs]
            The LLM model to use for judging. If not provided, uses the default judge LLM.

        skill_ids : typing.Optional[typing.Sequence[str]]
            List of skill IDs to enable for this task. Use ['*'] to enable all available skills for the project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TaskCreatedResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tasks",
            method="POST",
            json={
                "task": task,
                "llm": llm,
                "startUrl": start_url,
                "maxSteps": max_steps,
                "structuredOutput": structured_output,
                "sessionId": session_id,
                "metadata": metadata,
                "secrets": secrets,
                "allowedDomains": allowed_domains,
                "opVaultId": op_vault_id,
                "highlightElements": highlight_elements,
                "flashMode": flash_mode,
                "thinking": thinking,
                "vision": convert_and_respect_annotation_metadata(
                    object_=vision, annotation=CreateTaskRequestVision, direction="write"
                ),
                "systemPromptExtension": system_prompt_extension,
                "judge": judge,
                "judgeGroundTruth": judge_ground_truth,
                "judgeLlm": judge_llm,
                "skillIds": skill_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskCreatedResponse,
                    construct_type(
                        type_=TaskCreatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        TooManyConcurrentActiveSessionsError,
                        construct_type(
                            type_=TooManyConcurrentActiveSessionsError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_task(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[TaskView]:
        """
        Get detailed task information including status, progress, steps, and file outputs.

        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TaskView]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskView,
                    construct_type(
                        type_=TaskView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_task(
        self, task_id: str, *, action: TaskUpdateAction, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[TaskView]:
        """
        Control task execution with stop, pause, resume, or stop task and session actions.

        Parameters
        ----------
        task_id : str

        action : TaskUpdateAction
            The action to perform on the task

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TaskView]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}",
            method="PATCH",
            json={
                "action": action,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskView,
                    construct_type(
                        type_=TaskView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_task_logs(
        self, task_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[TaskLogFileResponse]:
        """
        Get secure download URL for task execution logs with step-by-step details.

        Parameters
        ----------
        task_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TaskLogFileResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tasks/{jsonable_encoder(task_id)}/logs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskLogFileResponse,
                    construct_type(
                        type_=TaskLogFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
