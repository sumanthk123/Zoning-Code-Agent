# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.workflow_create_from_task_response import WorkflowCreateFromTaskResponse
from ..types.workflow_execution_created_response import WorkflowExecutionCreatedResponse
from ..types.workflow_execution_list_response import WorkflowExecutionListResponse
from ..types.workflow_execution_log_response import WorkflowExecutionLogResponse
from ..types.workflow_execution_media_view import WorkflowExecutionMediaView
from ..types.workflow_execution_response import WorkflowExecutionResponse
from ..types.workflow_execution_state_view import WorkflowExecutionStateView
from ..types.workflow_execution_status import WorkflowExecutionStatus
from ..types.workflow_generate_response import WorkflowGenerateResponse
from ..types.workflow_generation_state_view import WorkflowGenerationStateView
from ..types.workflow_list_response import WorkflowListResponse
from ..types.workflow_response import WorkflowResponse
from ..types.workflow_yaml_presigned_upload_response import WorkflowYamlPresignedUploadResponse
from .raw_client import AsyncRawWorkflowsClient, RawWorkflowsClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class WorkflowsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawWorkflowsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawWorkflowsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawWorkflowsClient
        """
        return self._raw_client

    def list_workflows(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        is_archived: typing.Optional[bool] = None,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowListResponse:
        """
        Get paginated list of workflows with optional filtering.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        is_archived : typing.Optional[bool]

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowListResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.list_workflows()
        """
        _response = self._raw_client.list_workflows(
            page_size=page_size,
            page_number=page_number,
            is_archived=is_archived,
            user_id=user_id,
            request_options=request_options,
        )
        return _response.data

    def create_workflow(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowResponse:
        """
        Create a new workflow. The workflow YAML should be uploaded separately via the update endpoint.

        Parameters
        ----------
        name : str
            Name of the workflow

        description : typing.Optional[str]
            Optional description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.create_workflow(
            name="name",
        )
        """
        _response = self._raw_client.create_workflow(
            name=name, description=description, variables=variables, request_options=request_options
        )
        return _response.data

    def get_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowResponse:
        """
        Get detailed workflow information including presigned URL to download YAML.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.get_workflow(
            workflow_id="workflow_id",
        )
        """
        _response = self._raw_client.get_workflow(workflow_id, request_options=request_options)
        return _response.data

    def delete_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowResponse:
        """
        Archive a workflow (soft delete).

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.delete_workflow(
            workflow_id="workflow_id",
        )
        """
        _response = self._raw_client.delete_workflow(workflow_id, request_options=request_options)
        return _response.data

    def update_workflow(
        self,
        workflow_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowResponse:
        """
        Update workflow metadata.

        Parameters
        ----------
        workflow_id : str

        name : typing.Optional[str]
            Name of the workflow

        description : typing.Optional[str]
            Description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.update_workflow(
            workflow_id="workflow_id",
        )
        """
        _response = self._raw_client.update_workflow(
            workflow_id, name=name, description=description, variables=variables, request_options=request_options
        )
        return _response.data

    def get_workflow_generation_state(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowGenerationStateView:
        """
        Get workflow generation state with live browser URL for polling.

        This endpoint returns the current state of workflow generation including
        the live browser URL (if available). It's designed to be polled every 2 seconds
        during generation to show real-time browser activity in the frontend.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowGenerationStateView
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.get_workflow_generation_state(
            workflow_id="workflow_id",
        )
        """
        _response = self._raw_client.get_workflow_generation_state(workflow_id, request_options=request_options)
        return _response.data

    def create_workflow_from_task(
        self,
        *,
        name: str,
        task_id: str,
        session_id: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowCreateFromTaskResponse:
        """
        Create a workflow from an existing agent task's recorded history.

        This endpoint creates a workflow by using the browser-use rerun history
        feature. The task must have completed with history stored in S3.

        The workflow creation process:
        1. Creates a new workflow record in pending state
        2. Triggers an Inngest event to process the task history
        3. The Inngest handler downloads history, detects variables, and updates the workflow

        Use GET /workflows/{workflow_id} to poll for creation completion.

        Parameters
        ----------
        name : str
            Name for the new workflow

        task_id : str
            ID of the agent task to create workflow from

        session_id : str
            ID of the agent session containing the task

        description : typing.Optional[str]
            Optional description for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowCreateFromTaskResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.create_workflow_from_task(
            name="name",
            task_id="taskId",
            session_id="sessionId",
        )
        """
        _response = self._raw_client.create_workflow_from_task(
            name=name, task_id=task_id, session_id=session_id, description=description, request_options=request_options
        )
        return _response.data

    def get_workflow_yaml_presigned_url(
        self,
        workflow_id: str,
        *,
        size_bytes: int,
        file_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowYamlPresignedUploadResponse:
        """
        Get a presigned URL to upload workflow YAML directly to S3 from the browser.

        This avoids sending the YAML content through the backend, reducing latency
        and avoiding KMS permission issues in local development.

        Parameters
        ----------
        workflow_id : str

        size_bytes : int
            Size of the YAML file in bytes

        file_name : typing.Optional[str]
            The name of the YAML file to upload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowYamlPresignedUploadResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.get_workflow_yaml_presigned_url(
            workflow_id="workflow_id",
            size_bytes=1,
        )
        """
        _response = self._raw_client.get_workflow_yaml_presigned_url(
            workflow_id, size_bytes=size_bytes, file_name=file_name, request_options=request_options
        )
        return _response.data

    def run_workflow(
        self,
        workflow_id: str,
        *,
        input: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        execution_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowExecutionCreatedResponse:
        """
        Execute a workflow asynchronously.

        Returns execution ID immediately and processes in background via Inngest.
        Use the GET /workflows/executions/{execution_id} endpoint to check status and retrieve results.

        Parameters
        ----------
        workflow_id : str

        input : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input parameters for the workflow execution

        execution_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for this execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionCreatedResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.run_workflow(
            workflow_id="workflow_id",
        )
        """
        _response = self._raw_client.run_workflow(
            workflow_id, input=input, execution_metadata=execution_metadata, request_options=request_options
        )
        return _response.data

    def generate_workflow(
        self,
        workflow_id: str,
        *,
        task_prompt: str,
        workflow_name: typing.Optional[str] = OMIT,
        enable_variable_extraction: typing.Optional[bool] = OMIT,
        use_deterministic_conversion: typing.Optional[bool] = OMIT,
        use_cloud_browser: typing.Optional[bool] = OMIT,
        enable_pattern_variable_identification: typing.Optional[bool] = OMIT,
        pattern_variable_confidence: typing.Optional[float] = OMIT,
        enable_ai_validation: typing.Optional[bool] = OMIT,
        cleanup_yaml: typing.Optional[bool] = OMIT,
        remove_descriptions: typing.Optional[bool] = OMIT,
        remove_verification_checks: typing.Optional[bool] = OMIT,
        remove_expected_outcomes: typing.Optional[bool] = OMIT,
        remove_agent_reasoning: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowGenerateResponse:
        """
        Generate a workflow from a natural language task description.

        This endpoint uses the workflow-use library's HealingService to:
        1. Record browser interactions for the task
        2. Convert interactions to a reusable workflow
        3. Extract variables for parameterization
        4. Save the generated YAML to S3

        The generation happens asynchronously via the workflow_worker Lambda.

        Parameters
        ----------
        workflow_id : str

        task_prompt : str
            Natural language description of the task to automate

        workflow_name : typing.Optional[str]
            Optional name for the generated workflow. If not provided, will be inferred from prompt.

        enable_variable_extraction : typing.Optional[bool]
            Whether to extract reusable variables from the workflow

        use_deterministic_conversion : typing.Optional[bool]
            Whether to use deterministic conversion (faster and cheaper)

        use_cloud_browser : typing.Optional[bool]
            Whether to use cloud browser for recording (recommended for production)

        enable_pattern_variable_identification : typing.Optional[bool]
            Enable pattern-based variable identification (no LLM, $0 cost)

        pattern_variable_confidence : typing.Optional[float]
            Minimum confidence threshold for pattern-based detection (0.0 to 1.0)

        enable_ai_validation : typing.Optional[bool]
            Enable AI validation to review and fix generated workflow

        cleanup_yaml : typing.Optional[bool]
            Remove verbose fields from generated YAML

        remove_descriptions : typing.Optional[bool]
            Remove step descriptions (only if cleanup_yaml=True)

        remove_verification_checks : typing.Optional[bool]
            Remove verification_checks (only if cleanup_yaml=True)

        remove_expected_outcomes : typing.Optional[bool]
            Remove expected_outcome fields (only if cleanup_yaml=True)

        remove_agent_reasoning : typing.Optional[bool]
            Remove agent_reasoning fields (only if cleanup_yaml=True)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowGenerateResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.generate_workflow(
            workflow_id="workflow_id",
            task_prompt="Go to github.com and search for browser-use",
        )
        """
        _response = self._raw_client.generate_workflow(
            workflow_id,
            task_prompt=task_prompt,
            workflow_name=workflow_name,
            enable_variable_extraction=enable_variable_extraction,
            use_deterministic_conversion=use_deterministic_conversion,
            use_cloud_browser=use_cloud_browser,
            enable_pattern_variable_identification=enable_pattern_variable_identification,
            pattern_variable_confidence=pattern_variable_confidence,
            enable_ai_validation=enable_ai_validation,
            cleanup_yaml=cleanup_yaml,
            remove_descriptions=remove_descriptions,
            remove_verification_checks=remove_verification_checks,
            remove_expected_outcomes=remove_expected_outcomes,
            remove_agent_reasoning=remove_agent_reasoning,
            request_options=request_options,
        )
        return _response.data

    def get_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionResponse:
        """
        Get detailed execution information including status, results, and costs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.get_execution(
            execution_id="execution_id",
        )
        """
        _response = self._raw_client.get_execution(execution_id, request_options=request_options)
        return _response.data

    def list_workflow_executions(
        self,
        workflow_id_: str,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowExecutionListResponse:
        """
        Get paginated list of executions for a specific workflow.

        Parameters
        ----------
        workflow_id_ : str

        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionListResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.list_workflow_executions(
            workflow_id_="workflow_id",
        )
        """
        _response = self._raw_client.list_workflow_executions(
            workflow_id_,
            page_size=page_size,
            page_number=page_number,
            status=status,
            workflow_id=workflow_id,
            request_options=request_options,
        )
        return _response.data

    def list_all_executions(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowExecutionListResponse:
        """
        Get paginated list of all workflow executions for a project.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionListResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.list_all_executions()
        """
        _response = self._raw_client.list_all_executions(
            page_size=page_size,
            page_number=page_number,
            status=status,
            workflow_id=workflow_id,
            request_options=request_options,
        )
        return _response.data

    def cancel_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionResponse:
        """
        Cancel a pending or running workflow execution.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.cancel_execution(
            execution_id="execution_id",
        )
        """
        _response = self._raw_client.cancel_execution(execution_id, request_options=request_options)
        return _response.data

    def get_execution_logs(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionLogResponse:
        """
        Get presigned URL to download execution logs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionLogResponse
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.get_execution_logs(
            execution_id="execution_id",
        )
        """
        _response = self._raw_client.get_execution_logs(execution_id, request_options=request_options)
        return _response.data

    def get_execution_state(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionStateView:
        """
        Get workflow execution state with steps for live UI polling.

        This endpoint returns the current state of a workflow execution including all steps
        with their details. It's designed to be polled every 2 seconds during execution
        to show real-time progress in the frontend.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionStateView
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.get_execution_state(
            execution_id="execution_id",
        )
        """
        _response = self._raw_client.get_execution_state(execution_id, request_options=request_options)
        return _response.data

    def get_execution_media(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionMediaView:
        """
        Get workflow execution media (screenshots) with presigned URLs.

        This endpoint returns media URLs for completed executions. Screenshots
        are returned with presigned S3 URLs for direct access from the frontend.
        Should be called when execution status is 'completed', 'failed', or 'cancelled'.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionMediaView
            Successful Response

        Examples
        --------
        from browser_use_sdk import BrowserUse

        client = BrowserUse(
            api_key="YOUR_API_KEY",
        )
        client.workflows.get_execution_media(
            execution_id="execution_id",
        )
        """
        _response = self._raw_client.get_execution_media(execution_id, request_options=request_options)
        return _response.data


class AsyncWorkflowsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawWorkflowsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawWorkflowsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawWorkflowsClient
        """
        return self._raw_client

    async def list_workflows(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        is_archived: typing.Optional[bool] = None,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowListResponse:
        """
        Get paginated list of workflows with optional filtering.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        is_archived : typing.Optional[bool]

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowListResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.list_workflows()


        asyncio.run(main())
        """
        _response = await self._raw_client.list_workflows(
            page_size=page_size,
            page_number=page_number,
            is_archived=is_archived,
            user_id=user_id,
            request_options=request_options,
        )
        return _response.data

    async def create_workflow(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowResponse:
        """
        Create a new workflow. The workflow YAML should be uploaded separately via the update endpoint.

        Parameters
        ----------
        name : str
            Name of the workflow

        description : typing.Optional[str]
            Optional description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.create_workflow(
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_workflow(
            name=name, description=description, variables=variables, request_options=request_options
        )
        return _response.data

    async def get_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowResponse:
        """
        Get detailed workflow information including presigned URL to download YAML.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.get_workflow(
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_workflow(workflow_id, request_options=request_options)
        return _response.data

    async def delete_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowResponse:
        """
        Archive a workflow (soft delete).

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.delete_workflow(
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.delete_workflow(workflow_id, request_options=request_options)
        return _response.data

    async def update_workflow(
        self,
        workflow_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowResponse:
        """
        Update workflow metadata.

        Parameters
        ----------
        workflow_id : str

        name : typing.Optional[str]
            Name of the workflow

        description : typing.Optional[str]
            Description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.update_workflow(
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update_workflow(
            workflow_id, name=name, description=description, variables=variables, request_options=request_options
        )
        return _response.data

    async def get_workflow_generation_state(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowGenerationStateView:
        """
        Get workflow generation state with live browser URL for polling.

        This endpoint returns the current state of workflow generation including
        the live browser URL (if available). It's designed to be polled every 2 seconds
        during generation to show real-time browser activity in the frontend.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowGenerationStateView
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.get_workflow_generation_state(
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_workflow_generation_state(workflow_id, request_options=request_options)
        return _response.data

    async def create_workflow_from_task(
        self,
        *,
        name: str,
        task_id: str,
        session_id: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowCreateFromTaskResponse:
        """
        Create a workflow from an existing agent task's recorded history.

        This endpoint creates a workflow by using the browser-use rerun history
        feature. The task must have completed with history stored in S3.

        The workflow creation process:
        1. Creates a new workflow record in pending state
        2. Triggers an Inngest event to process the task history
        3. The Inngest handler downloads history, detects variables, and updates the workflow

        Use GET /workflows/{workflow_id} to poll for creation completion.

        Parameters
        ----------
        name : str
            Name for the new workflow

        task_id : str
            ID of the agent task to create workflow from

        session_id : str
            ID of the agent session containing the task

        description : typing.Optional[str]
            Optional description for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowCreateFromTaskResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.create_workflow_from_task(
                name="name",
                task_id="taskId",
                session_id="sessionId",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create_workflow_from_task(
            name=name, task_id=task_id, session_id=session_id, description=description, request_options=request_options
        )
        return _response.data

    async def get_workflow_yaml_presigned_url(
        self,
        workflow_id: str,
        *,
        size_bytes: int,
        file_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowYamlPresignedUploadResponse:
        """
        Get a presigned URL to upload workflow YAML directly to S3 from the browser.

        This avoids sending the YAML content through the backend, reducing latency
        and avoiding KMS permission issues in local development.

        Parameters
        ----------
        workflow_id : str

        size_bytes : int
            Size of the YAML file in bytes

        file_name : typing.Optional[str]
            The name of the YAML file to upload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowYamlPresignedUploadResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.get_workflow_yaml_presigned_url(
                workflow_id="workflow_id",
                size_bytes=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_workflow_yaml_presigned_url(
            workflow_id, size_bytes=size_bytes, file_name=file_name, request_options=request_options
        )
        return _response.data

    async def run_workflow(
        self,
        workflow_id: str,
        *,
        input: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        execution_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowExecutionCreatedResponse:
        """
        Execute a workflow asynchronously.

        Returns execution ID immediately and processes in background via Inngest.
        Use the GET /workflows/executions/{execution_id} endpoint to check status and retrieve results.

        Parameters
        ----------
        workflow_id : str

        input : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input parameters for the workflow execution

        execution_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for this execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionCreatedResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.run_workflow(
                workflow_id="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.run_workflow(
            workflow_id, input=input, execution_metadata=execution_metadata, request_options=request_options
        )
        return _response.data

    async def generate_workflow(
        self,
        workflow_id: str,
        *,
        task_prompt: str,
        workflow_name: typing.Optional[str] = OMIT,
        enable_variable_extraction: typing.Optional[bool] = OMIT,
        use_deterministic_conversion: typing.Optional[bool] = OMIT,
        use_cloud_browser: typing.Optional[bool] = OMIT,
        enable_pattern_variable_identification: typing.Optional[bool] = OMIT,
        pattern_variable_confidence: typing.Optional[float] = OMIT,
        enable_ai_validation: typing.Optional[bool] = OMIT,
        cleanup_yaml: typing.Optional[bool] = OMIT,
        remove_descriptions: typing.Optional[bool] = OMIT,
        remove_verification_checks: typing.Optional[bool] = OMIT,
        remove_expected_outcomes: typing.Optional[bool] = OMIT,
        remove_agent_reasoning: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowGenerateResponse:
        """
        Generate a workflow from a natural language task description.

        This endpoint uses the workflow-use library's HealingService to:
        1. Record browser interactions for the task
        2. Convert interactions to a reusable workflow
        3. Extract variables for parameterization
        4. Save the generated YAML to S3

        The generation happens asynchronously via the workflow_worker Lambda.

        Parameters
        ----------
        workflow_id : str

        task_prompt : str
            Natural language description of the task to automate

        workflow_name : typing.Optional[str]
            Optional name for the generated workflow. If not provided, will be inferred from prompt.

        enable_variable_extraction : typing.Optional[bool]
            Whether to extract reusable variables from the workflow

        use_deterministic_conversion : typing.Optional[bool]
            Whether to use deterministic conversion (faster and cheaper)

        use_cloud_browser : typing.Optional[bool]
            Whether to use cloud browser for recording (recommended for production)

        enable_pattern_variable_identification : typing.Optional[bool]
            Enable pattern-based variable identification (no LLM, $0 cost)

        pattern_variable_confidence : typing.Optional[float]
            Minimum confidence threshold for pattern-based detection (0.0 to 1.0)

        enable_ai_validation : typing.Optional[bool]
            Enable AI validation to review and fix generated workflow

        cleanup_yaml : typing.Optional[bool]
            Remove verbose fields from generated YAML

        remove_descriptions : typing.Optional[bool]
            Remove step descriptions (only if cleanup_yaml=True)

        remove_verification_checks : typing.Optional[bool]
            Remove verification_checks (only if cleanup_yaml=True)

        remove_expected_outcomes : typing.Optional[bool]
            Remove expected_outcome fields (only if cleanup_yaml=True)

        remove_agent_reasoning : typing.Optional[bool]
            Remove agent_reasoning fields (only if cleanup_yaml=True)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowGenerateResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.generate_workflow(
                workflow_id="workflow_id",
                task_prompt="Go to github.com and search for browser-use",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.generate_workflow(
            workflow_id,
            task_prompt=task_prompt,
            workflow_name=workflow_name,
            enable_variable_extraction=enable_variable_extraction,
            use_deterministic_conversion=use_deterministic_conversion,
            use_cloud_browser=use_cloud_browser,
            enable_pattern_variable_identification=enable_pattern_variable_identification,
            pattern_variable_confidence=pattern_variable_confidence,
            enable_ai_validation=enable_ai_validation,
            cleanup_yaml=cleanup_yaml,
            remove_descriptions=remove_descriptions,
            remove_verification_checks=remove_verification_checks,
            remove_expected_outcomes=remove_expected_outcomes,
            remove_agent_reasoning=remove_agent_reasoning,
            request_options=request_options,
        )
        return _response.data

    async def get_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionResponse:
        """
        Get detailed execution information including status, results, and costs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.get_execution(
                execution_id="execution_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_execution(execution_id, request_options=request_options)
        return _response.data

    async def list_workflow_executions(
        self,
        workflow_id_: str,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowExecutionListResponse:
        """
        Get paginated list of executions for a specific workflow.

        Parameters
        ----------
        workflow_id_ : str

        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionListResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.list_workflow_executions(
                workflow_id_="workflow_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.list_workflow_executions(
            workflow_id_,
            page_size=page_size,
            page_number=page_number,
            status=status,
            workflow_id=workflow_id,
            request_options=request_options,
        )
        return _response.data

    async def list_all_executions(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowExecutionListResponse:
        """
        Get paginated list of all workflow executions for a project.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionListResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.list_all_executions()


        asyncio.run(main())
        """
        _response = await self._raw_client.list_all_executions(
            page_size=page_size,
            page_number=page_number,
            status=status,
            workflow_id=workflow_id,
            request_options=request_options,
        )
        return _response.data

    async def cancel_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionResponse:
        """
        Cancel a pending or running workflow execution.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.cancel_execution(
                execution_id="execution_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.cancel_execution(execution_id, request_options=request_options)
        return _response.data

    async def get_execution_logs(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionLogResponse:
        """
        Get presigned URL to download execution logs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionLogResponse
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.get_execution_logs(
                execution_id="execution_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_execution_logs(execution_id, request_options=request_options)
        return _response.data

    async def get_execution_state(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionStateView:
        """
        Get workflow execution state with steps for live UI polling.

        This endpoint returns the current state of a workflow execution including all steps
        with their details. It's designed to be polled every 2 seconds during execution
        to show real-time progress in the frontend.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionStateView
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.get_execution_state(
                execution_id="execution_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_execution_state(execution_id, request_options=request_options)
        return _response.data

    async def get_execution_media(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> WorkflowExecutionMediaView:
        """
        Get workflow execution media (screenshots) with presigned URLs.

        This endpoint returns media URLs for completed executions. Screenshots
        are returned with presigned S3 URLs for direct access from the frontend.
        Should be called when execution status is 'completed', 'failed', or 'cancelled'.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowExecutionMediaView
            Successful Response

        Examples
        --------
        import asyncio

        from browser_use_sdk import AsyncBrowserUse

        client = AsyncBrowserUse(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.workflows.get_execution_media(
                execution_id="execution_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_execution_media(execution_id, request_options=request_options)
        return _response.data
