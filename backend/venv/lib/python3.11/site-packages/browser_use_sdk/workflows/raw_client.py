# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.not_found_error import NotFoundError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.workflow_create_from_task_response import WorkflowCreateFromTaskResponse
from ..types.workflow_execution_created_response import WorkflowExecutionCreatedResponse
from ..types.workflow_execution_list_response import WorkflowExecutionListResponse
from ..types.workflow_execution_log_response import WorkflowExecutionLogResponse
from ..types.workflow_execution_media_view import WorkflowExecutionMediaView
from ..types.workflow_execution_response import WorkflowExecutionResponse
from ..types.workflow_execution_state_view import WorkflowExecutionStateView
from ..types.workflow_execution_status import WorkflowExecutionStatus
from ..types.workflow_generate_response import WorkflowGenerateResponse
from ..types.workflow_generation_state_view import WorkflowGenerationStateView
from ..types.workflow_list_response import WorkflowListResponse
from ..types.workflow_response import WorkflowResponse
from ..types.workflow_yaml_presigned_upload_response import WorkflowYamlPresignedUploadResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawWorkflowsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_workflows(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        is_archived: typing.Optional[bool] = None,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowListResponse]:
        """
        Get paginated list of workflows with optional filtering.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        is_archived : typing.Optional[bool]

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "isArchived": is_archived,
                "userId": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowListResponse,
                    construct_type(
                        type_=WorkflowListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_workflow(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowResponse]:
        """
        Create a new workflow. The workflow YAML should be uploaded separately via the update endpoint.

        Parameters
        ----------
        name : str
            Name of the workflow

        description : typing.Optional[str]
            Optional description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows",
            method="POST",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Get detailed workflow information including presigned URL to download YAML.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowResponse]:
        """
        Archive a workflow (soft delete).

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_workflow(
        self,
        workflow_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowResponse]:
        """
        Update workflow metadata.

        Parameters
        ----------
        workflow_id : str

        name : typing.Optional[str]
            Name of the workflow

        description : typing.Optional[str]
            Description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_workflow_generation_state(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowGenerationStateView]:
        """
        Get workflow generation state with live browser URL for polling.

        This endpoint returns the current state of workflow generation including
        the live browser URL (if available). It's designed to be polled every 2 seconds
        during generation to show real-time browser activity in the frontend.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowGenerationStateView]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/generation-state",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowGenerationStateView,
                    construct_type(
                        type_=WorkflowGenerationStateView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_workflow_from_task(
        self,
        *,
        name: str,
        task_id: str,
        session_id: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowCreateFromTaskResponse]:
        """
        Create a workflow from an existing agent task's recorded history.

        This endpoint creates a workflow by using the browser-use rerun history
        feature. The task must have completed with history stored in S3.

        The workflow creation process:
        1. Creates a new workflow record in pending state
        2. Triggers an Inngest event to process the task history
        3. The Inngest handler downloads history, detects variables, and updates the workflow

        Use GET /workflows/{workflow_id} to poll for creation completion.

        Parameters
        ----------
        name : str
            Name for the new workflow

        task_id : str
            ID of the agent task to create workflow from

        session_id : str
            ID of the agent session containing the task

        description : typing.Optional[str]
            Optional description for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowCreateFromTaskResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows/from-task",
            method="POST",
            json={
                "name": name,
                "taskId": task_id,
                "sessionId": session_id,
                "description": description,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowCreateFromTaskResponse,
                    construct_type(
                        type_=WorkflowCreateFromTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_workflow_yaml_presigned_url(
        self,
        workflow_id: str,
        *,
        size_bytes: int,
        file_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowYamlPresignedUploadResponse]:
        """
        Get a presigned URL to upload workflow YAML directly to S3 from the browser.

        This avoids sending the YAML content through the backend, reducing latency
        and avoiding KMS permission issues in local development.

        Parameters
        ----------
        workflow_id : str

        size_bytes : int
            Size of the YAML file in bytes

        file_name : typing.Optional[str]
            The name of the YAML file to upload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowYamlPresignedUploadResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/yaml/presigned-url",
            method="POST",
            json={
                "fileName": file_name,
                "sizeBytes": size_bytes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowYamlPresignedUploadResponse,
                    construct_type(
                        type_=WorkflowYamlPresignedUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def run_workflow(
        self,
        workflow_id: str,
        *,
        input: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        execution_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowExecutionCreatedResponse]:
        """
        Execute a workflow asynchronously.

        Returns execution ID immediately and processes in background via Inngest.
        Use the GET /workflows/executions/{execution_id} endpoint to check status and retrieve results.

        Parameters
        ----------
        workflow_id : str

        input : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input parameters for the workflow execution

        execution_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for this execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionCreatedResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/run",
            method="POST",
            json={
                "input": input,
                "executionMetadata": execution_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionCreatedResponse,
                    construct_type(
                        type_=WorkflowExecutionCreatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_workflow(
        self,
        workflow_id: str,
        *,
        task_prompt: str,
        workflow_name: typing.Optional[str] = OMIT,
        enable_variable_extraction: typing.Optional[bool] = OMIT,
        use_deterministic_conversion: typing.Optional[bool] = OMIT,
        use_cloud_browser: typing.Optional[bool] = OMIT,
        enable_pattern_variable_identification: typing.Optional[bool] = OMIT,
        pattern_variable_confidence: typing.Optional[float] = OMIT,
        enable_ai_validation: typing.Optional[bool] = OMIT,
        cleanup_yaml: typing.Optional[bool] = OMIT,
        remove_descriptions: typing.Optional[bool] = OMIT,
        remove_verification_checks: typing.Optional[bool] = OMIT,
        remove_expected_outcomes: typing.Optional[bool] = OMIT,
        remove_agent_reasoning: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowGenerateResponse]:
        """
        Generate a workflow from a natural language task description.

        This endpoint uses the workflow-use library's HealingService to:
        1. Record browser interactions for the task
        2. Convert interactions to a reusable workflow
        3. Extract variables for parameterization
        4. Save the generated YAML to S3

        The generation happens asynchronously via the workflow_worker Lambda.

        Parameters
        ----------
        workflow_id : str

        task_prompt : str
            Natural language description of the task to automate

        workflow_name : typing.Optional[str]
            Optional name for the generated workflow. If not provided, will be inferred from prompt.

        enable_variable_extraction : typing.Optional[bool]
            Whether to extract reusable variables from the workflow

        use_deterministic_conversion : typing.Optional[bool]
            Whether to use deterministic conversion (faster and cheaper)

        use_cloud_browser : typing.Optional[bool]
            Whether to use cloud browser for recording (recommended for production)

        enable_pattern_variable_identification : typing.Optional[bool]
            Enable pattern-based variable identification (no LLM, $0 cost)

        pattern_variable_confidence : typing.Optional[float]
            Minimum confidence threshold for pattern-based detection (0.0 to 1.0)

        enable_ai_validation : typing.Optional[bool]
            Enable AI validation to review and fix generated workflow

        cleanup_yaml : typing.Optional[bool]
            Remove verbose fields from generated YAML

        remove_descriptions : typing.Optional[bool]
            Remove step descriptions (only if cleanup_yaml=True)

        remove_verification_checks : typing.Optional[bool]
            Remove verification_checks (only if cleanup_yaml=True)

        remove_expected_outcomes : typing.Optional[bool]
            Remove expected_outcome fields (only if cleanup_yaml=True)

        remove_agent_reasoning : typing.Optional[bool]
            Remove agent_reasoning fields (only if cleanup_yaml=True)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowGenerateResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/generate",
            method="POST",
            json={
                "taskPrompt": task_prompt,
                "workflowName": workflow_name,
                "enableVariableExtraction": enable_variable_extraction,
                "useDeterministicConversion": use_deterministic_conversion,
                "useCloudBrowser": use_cloud_browser,
                "enablePatternVariableIdentification": enable_pattern_variable_identification,
                "patternVariableConfidence": pattern_variable_confidence,
                "enableAiValidation": enable_ai_validation,
                "cleanupYaml": cleanup_yaml,
                "removeDescriptions": remove_descriptions,
                "removeVerificationChecks": remove_verification_checks,
                "removeExpectedOutcomes": remove_expected_outcomes,
                "removeAgentReasoning": remove_agent_reasoning,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowGenerateResponse,
                    construct_type(
                        type_=WorkflowGenerateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionResponse]:
        """
        Get detailed execution information including status, results, and costs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_workflow_executions(
        self,
        workflow_id_: str,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of executions for a specific workflow.

        Parameters
        ----------
        workflow_id_ : str

        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id_)}/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_all_executions(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of all workflow executions for a project.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def cancel_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionResponse]:
        """
        Cancel a pending or running workflow execution.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/cancel",
            method="PATCH",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_execution_logs(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionLogResponse]:
        """
        Get presigned URL to download execution logs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionLogResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/logs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionLogResponse,
                    construct_type(
                        type_=WorkflowExecutionLogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_execution_state(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionStateView]:
        """
        Get workflow execution state with steps for live UI polling.

        This endpoint returns the current state of a workflow execution including all steps
        with their details. It's designed to be polled every 2 seconds during execution
        to show real-time progress in the frontend.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionStateView]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/state",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionStateView,
                    construct_type(
                        type_=WorkflowExecutionStateView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_execution_media(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkflowExecutionMediaView]:
        """
        Get workflow execution media (screenshots) with presigned URLs.

        This endpoint returns media URLs for completed executions. Screenshots
        are returned with presigned S3 URLs for direct access from the frontend.
        Should be called when execution status is 'completed', 'failed', or 'cancelled'.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkflowExecutionMediaView]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/media",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionMediaView,
                    construct_type(
                        type_=WorkflowExecutionMediaView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawWorkflowsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_workflows(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        is_archived: typing.Optional[bool] = None,
        user_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowListResponse]:
        """
        Get paginated list of workflows with optional filtering.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        is_archived : typing.Optional[bool]

        user_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "isArchived": is_archived,
                "userId": user_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowListResponse,
                    construct_type(
                        type_=WorkflowListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_workflow(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Create a new workflow. The workflow YAML should be uploaded separately via the update endpoint.

        Parameters
        ----------
        name : str
            Name of the workflow

        description : typing.Optional[str]
            Optional description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows",
            method="POST",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Get detailed workflow information including presigned URL to download YAML.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_workflow(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Archive a workflow (soft delete).

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_workflow(
        self,
        workflow_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        variables: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowResponse]:
        """
        Update workflow metadata.

        Parameters
        ----------
        workflow_id : str

        name : typing.Optional[str]
            Name of the workflow

        description : typing.Optional[str]
            Description of the workflow

        variables : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Variables/parameters for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "variables": variables,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowResponse,
                    construct_type(
                        type_=WorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_workflow_generation_state(
        self, workflow_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowGenerationStateView]:
        """
        Get workflow generation state with live browser URL for polling.

        This endpoint returns the current state of workflow generation including
        the live browser URL (if available). It's designed to be polled every 2 seconds
        during generation to show real-time browser activity in the frontend.

        Parameters
        ----------
        workflow_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowGenerationStateView]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/generation-state",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowGenerationStateView,
                    construct_type(
                        type_=WorkflowGenerationStateView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_workflow_from_task(
        self,
        *,
        name: str,
        task_id: str,
        session_id: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowCreateFromTaskResponse]:
        """
        Create a workflow from an existing agent task's recorded history.

        This endpoint creates a workflow by using the browser-use rerun history
        feature. The task must have completed with history stored in S3.

        The workflow creation process:
        1. Creates a new workflow record in pending state
        2. Triggers an Inngest event to process the task history
        3. The Inngest handler downloads history, detects variables, and updates the workflow

        Use GET /workflows/{workflow_id} to poll for creation completion.

        Parameters
        ----------
        name : str
            Name for the new workflow

        task_id : str
            ID of the agent task to create workflow from

        session_id : str
            ID of the agent session containing the task

        description : typing.Optional[str]
            Optional description for the workflow

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowCreateFromTaskResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows/from-task",
            method="POST",
            json={
                "name": name,
                "taskId": task_id,
                "sessionId": session_id,
                "description": description,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowCreateFromTaskResponse,
                    construct_type(
                        type_=WorkflowCreateFromTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_workflow_yaml_presigned_url(
        self,
        workflow_id: str,
        *,
        size_bytes: int,
        file_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowYamlPresignedUploadResponse]:
        """
        Get a presigned URL to upload workflow YAML directly to S3 from the browser.

        This avoids sending the YAML content through the backend, reducing latency
        and avoiding KMS permission issues in local development.

        Parameters
        ----------
        workflow_id : str

        size_bytes : int
            Size of the YAML file in bytes

        file_name : typing.Optional[str]
            The name of the YAML file to upload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowYamlPresignedUploadResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/yaml/presigned-url",
            method="POST",
            json={
                "fileName": file_name,
                "sizeBytes": size_bytes,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowYamlPresignedUploadResponse,
                    construct_type(
                        type_=WorkflowYamlPresignedUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def run_workflow(
        self,
        workflow_id: str,
        *,
        input: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        execution_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowExecutionCreatedResponse]:
        """
        Execute a workflow asynchronously.

        Returns execution ID immediately and processes in background via Inngest.
        Use the GET /workflows/executions/{execution_id} endpoint to check status and retrieve results.

        Parameters
        ----------
        workflow_id : str

        input : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Input parameters for the workflow execution

        execution_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Optional metadata for this execution

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionCreatedResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/run",
            method="POST",
            json={
                "input": input,
                "executionMetadata": execution_metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionCreatedResponse,
                    construct_type(
                        type_=WorkflowExecutionCreatedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_workflow(
        self,
        workflow_id: str,
        *,
        task_prompt: str,
        workflow_name: typing.Optional[str] = OMIT,
        enable_variable_extraction: typing.Optional[bool] = OMIT,
        use_deterministic_conversion: typing.Optional[bool] = OMIT,
        use_cloud_browser: typing.Optional[bool] = OMIT,
        enable_pattern_variable_identification: typing.Optional[bool] = OMIT,
        pattern_variable_confidence: typing.Optional[float] = OMIT,
        enable_ai_validation: typing.Optional[bool] = OMIT,
        cleanup_yaml: typing.Optional[bool] = OMIT,
        remove_descriptions: typing.Optional[bool] = OMIT,
        remove_verification_checks: typing.Optional[bool] = OMIT,
        remove_expected_outcomes: typing.Optional[bool] = OMIT,
        remove_agent_reasoning: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowGenerateResponse]:
        """
        Generate a workflow from a natural language task description.

        This endpoint uses the workflow-use library's HealingService to:
        1. Record browser interactions for the task
        2. Convert interactions to a reusable workflow
        3. Extract variables for parameterization
        4. Save the generated YAML to S3

        The generation happens asynchronously via the workflow_worker Lambda.

        Parameters
        ----------
        workflow_id : str

        task_prompt : str
            Natural language description of the task to automate

        workflow_name : typing.Optional[str]
            Optional name for the generated workflow. If not provided, will be inferred from prompt.

        enable_variable_extraction : typing.Optional[bool]
            Whether to extract reusable variables from the workflow

        use_deterministic_conversion : typing.Optional[bool]
            Whether to use deterministic conversion (faster and cheaper)

        use_cloud_browser : typing.Optional[bool]
            Whether to use cloud browser for recording (recommended for production)

        enable_pattern_variable_identification : typing.Optional[bool]
            Enable pattern-based variable identification (no LLM, $0 cost)

        pattern_variable_confidence : typing.Optional[float]
            Minimum confidence threshold for pattern-based detection (0.0 to 1.0)

        enable_ai_validation : typing.Optional[bool]
            Enable AI validation to review and fix generated workflow

        cleanup_yaml : typing.Optional[bool]
            Remove verbose fields from generated YAML

        remove_descriptions : typing.Optional[bool]
            Remove step descriptions (only if cleanup_yaml=True)

        remove_verification_checks : typing.Optional[bool]
            Remove verification_checks (only if cleanup_yaml=True)

        remove_expected_outcomes : typing.Optional[bool]
            Remove expected_outcome fields (only if cleanup_yaml=True)

        remove_agent_reasoning : typing.Optional[bool]
            Remove agent_reasoning fields (only if cleanup_yaml=True)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowGenerateResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id)}/generate",
            method="POST",
            json={
                "taskPrompt": task_prompt,
                "workflowName": workflow_name,
                "enableVariableExtraction": enable_variable_extraction,
                "useDeterministicConversion": use_deterministic_conversion,
                "useCloudBrowser": use_cloud_browser,
                "enablePatternVariableIdentification": enable_pattern_variable_identification,
                "patternVariableConfidence": pattern_variable_confidence,
                "enableAiValidation": enable_ai_validation,
                "cleanupYaml": cleanup_yaml,
                "removeDescriptions": remove_descriptions,
                "removeVerificationChecks": remove_verification_checks,
                "removeExpectedOutcomes": remove_expected_outcomes,
                "removeAgentReasoning": remove_agent_reasoning,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowGenerateResponse,
                    construct_type(
                        type_=WorkflowGenerateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionResponse]:
        """
        Get detailed execution information including status, results, and costs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_workflow_executions(
        self,
        workflow_id_: str,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of executions for a specific workflow.

        Parameters
        ----------
        workflow_id_ : str

        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/{jsonable_encoder(workflow_id_)}/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_all_executions(
        self,
        *,
        page_size: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        status: typing.Optional[WorkflowExecutionStatus] = None,
        workflow_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WorkflowExecutionListResponse]:
        """
        Get paginated list of all workflow executions for a project.

        Parameters
        ----------
        page_size : typing.Optional[int]

        page_number : typing.Optional[int]

        status : typing.Optional[WorkflowExecutionStatus]

        workflow_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionListResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows/executions",
            method="GET",
            params={
                "pageSize": page_size,
                "pageNumber": page_number,
                "status": status,
                "workflowId": workflow_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionListResponse,
                    construct_type(
                        type_=WorkflowExecutionListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def cancel_execution(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionResponse]:
        """
        Cancel a pending or running workflow execution.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/cancel",
            method="PATCH",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionResponse,
                    construct_type(
                        type_=WorkflowExecutionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_execution_logs(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionLogResponse]:
        """
        Get presigned URL to download execution logs.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionLogResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/logs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionLogResponse,
                    construct_type(
                        type_=WorkflowExecutionLogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_execution_state(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionStateView]:
        """
        Get workflow execution state with steps for live UI polling.

        This endpoint returns the current state of a workflow execution including all steps
        with their details. It's designed to be polled every 2 seconds during execution
        to show real-time progress in the frontend.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionStateView]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/state",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionStateView,
                    construct_type(
                        type_=WorkflowExecutionStateView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_execution_media(
        self, execution_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkflowExecutionMediaView]:
        """
        Get workflow execution media (screenshots) with presigned URLs.

        This endpoint returns media URLs for completed executions. Screenshots
        are returned with presigned S3 URLs for direct access from the frontend.
        Should be called when execution status is 'completed', 'failed', or 'cancelled'.

        Parameters
        ----------
        execution_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkflowExecutionMediaView]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/executions/{jsonable_encoder(execution_id)}/media",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkflowExecutionMediaView,
                    construct_type(
                        type_=WorkflowExecutionMediaView,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
